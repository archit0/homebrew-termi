#!/usr/bin/env python3
"""
Termi - A natural language terminal command executor.
Translates natural language to shell commands using LLM APIs.
"""

import os
import sys
import json
import re
import subprocess
import tty
import termios
from pathlib import Path

try:
    import requests
except ImportError:
    print("Error: 'requests' library is required. Install it with: pip install requests")
    sys.exit(1)

CONFIG_DIR = Path.home() / ".termi"
CONFIG_FILE = CONFIG_DIR / "config.json"

PROVIDERS = {
    "openai": {
        "suggested_models": ["gpt-5.2", "gpt-5-mini", "gpt-5-nano", "gpt-4o", "gpt-4o-mini"],
        "api_url": "https://api.openai.com/v1/chat/completions",
        "env_key": "OPENAI_API_KEY",
        "requires_key": True
    },
    "anthropic": {
        "suggested_models": ["claude-sonnet-4-5", "claude-haiku-4-5", "claude-opus-4-5"],
        "api_url": "https://api.anthropic.com/v1/messages",
        "env_key": "ANTHROPIC_API_KEY",
        "requires_key": True
    },
    "ollama": {
        "suggested_models": [],  # Dynamically fetched
        "api_url": "http://localhost:11434/api/chat",
        "tags_url": "http://localhost:11434/api/tags",
        "env_key": None,
        "requires_key": False
    }
}

SYSTEM_PROMPT = """You are a command-line assistant. Convert natural language requests into shell commands.

IMPORTANT: Always respond with valid JSON in this exact format:
{
  "commands": [
    {"cmd": "command here", "desc": "brief description"}
  ],
  "unsafe": false
}

Rules:
1. Return a JSON object with "commands" array and "unsafe" boolean
2. Each command has "cmd" (the shell command) and "desc" (brief description)
3. For multi-step tasks, return multiple commands in order (they run sequentially)
4. Use common Unix/Linux commands that work on most systems
5. Be conservative - prefer safe, non-destructive commands
6. Set "unsafe": true if the request is dangerous, unclear, or could cause harm

Examples:

User: "list all files"
{"commands": [{"cmd": "ls -la", "desc": "List all files including hidden"}], "unsafe": false}

User: "go to /tmp and create a folder called test"
{"commands": [{"cmd": "cd /tmp", "desc": "Change to /tmp directory"}, {"cmd": "mkdir test", "desc": "Create test folder"}], "unsafe": false}

User: "find python files and count them"
{"commands": [{"cmd": "find . -name '*.py' | wc -l", "desc": "Count Python files"}], "unsafe": false}

User: "delete everything"
{"commands": [], "unsafe": true}

User: "rm -rf /"
{"commands": [], "unsafe": true}"""

# Terminal colors
CYAN = "\033[96m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
BOLD = "\033[1m"
DIM = "\033[2m"
RESET = "\033[0m"
CLEAR_LINE = "\033[2K"


def get_ollama_models():
    """Fetch available models from Ollama."""
    try:
        response = requests.get(
            PROVIDERS["ollama"]["tags_url"],
            timeout=5
        )
        response.raise_for_status()
        data = response.json()
        models = [model["name"] for model in data.get("models", [])]
        return models
    except requests.exceptions.ConnectionError:
        return None  # Ollama not running
    except Exception:
        return []


def check_ollama_running():
    """Check if Ollama is running."""
    try:
        response = requests.get(
            "http://localhost:11434/api/tags",
            timeout=3
        )
        return response.status_code == 200
    except Exception:
        return False


def get_key():
    """Read a single keypress from stdin."""
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
        # Handle escape sequences (arrow keys)
        if ch == '\x1b':
            ch2 = sys.stdin.read(1)
            if ch2 == '[':
                ch3 = sys.stdin.read(1)
                if ch3 == 'A':
                    return 'UP'
                elif ch3 == 'B':
                    return 'DOWN'
                elif ch3 == 'C':
                    return 'RIGHT'
                elif ch3 == 'D':
                    return 'LEFT'
            return 'ESC'
        return ch
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)


def interactive_select(title, options, allow_custom=False, allow_back=False):
    """
    Display an interactive selection menu with arrow key navigation.
    Returns the selected option, custom input, or None if back is selected.
    """
    display_options = list(options)
    if allow_custom:
        display_options.append("[ Enter custom value ]")
    if allow_back:
        display_options.insert(0, f"{DIM}← Back{RESET}")

    selected = 1 if allow_back else 0  # Start on first real option if back exists

    # Hide cursor
    sys.stdout.write("\033[?25l")
    sys.stdout.flush()

    try:
        while True:
            # Print title
            sys.stdout.write(f"\n{BOLD}{CYAN}{title}{RESET}\n")
            hint = "Use ↑↓ to navigate, Enter to select"
            if allow_back:
                hint += ", Esc to go back"
            sys.stdout.write(f"{DIM}{hint}{RESET}\n\n")

            # Print options
            for i, option in enumerate(display_options):
                if i == selected:
                    sys.stdout.write(f"  {GREEN}❯ {option}{RESET}\n")
                else:
                    sys.stdout.write(f"    {DIM}{option}{RESET}\n")

            sys.stdout.flush()

            # Get keypress
            key = get_key()

            if key == 'UP' or key == 'k':
                selected = (selected - 1) % len(display_options)
            elif key == 'DOWN' or key == 'j':
                selected = (selected + 1) % len(display_options)
            elif key == '\r' or key == '\n':  # Enter
                break
            elif key == 'ESC' and allow_back:  # Escape to go back
                selected = 0  # Select back option
                break
            elif key == 'q' or key == '\x03':  # q or Ctrl+C
                sys.stdout.write("\033[?25h")  # Show cursor
                sys.stdout.write("\n")
                sys.exit(0)

            # Move cursor up to redraw
            lines_to_clear = len(display_options) + 4
            sys.stdout.write(f"\033[{lines_to_clear}A")
            for _ in range(lines_to_clear):
                sys.stdout.write(f"{CLEAR_LINE}\n")
            sys.stdout.write(f"\033[{lines_to_clear}A")

        # Show cursor
        sys.stdout.write("\033[?25h")
        sys.stdout.write("\n")

        # Handle back option
        if allow_back and selected == 0:
            return None  # Signal to go back

        # Adjust index if back option exists
        actual_idx = selected - 1 if allow_back else selected

        # Handle custom input
        custom_idx = len(options)  # Index of custom option in original list
        if allow_custom and actual_idx == custom_idx:
            custom_val = input(f"{CYAN}Enter custom value: {RESET}").strip()
            if not custom_val:
                return None  # Treat empty as back
            return custom_val

        return options[actual_idx]

    except Exception:
        # Ensure cursor is shown on error
        sys.stdout.write("\033[?25h\n")
        raise


def interactive_confirm(prompt, default=True, allow_always=False):
    """
    Display an interactive confirmation.
    Returns: True (yes), False (no), or 'always' if allow_always is True.
    """
    if allow_always:
        options = ["Yes", "No", "Always"]
    else:
        options = ["Yes", "No"] if default else ["No", "Yes"]

    selected = 0

    sys.stdout.write("\033[?25l")  # Hide cursor
    sys.stdout.flush()

    try:
        while True:
            # Build the line
            line = f"{BOLD}{prompt}{RESET}  "
            for i, opt in enumerate(options):
                if i == selected:
                    line += f" {GREEN}[{opt}]{RESET} "
                else:
                    line += f" {DIM}{opt}{RESET} "

            # Clear current line and write
            sys.stdout.write(f"\r{CLEAR_LINE}{line}")
            sys.stdout.flush()

            key = get_key()

            if key == 'LEFT' or key == 'h':
                selected = (selected - 1) % len(options)
            elif key == 'RIGHT' or key == 'l':
                selected = (selected + 1) % len(options)
            elif key == '\r' or key == '\n':
                break
            elif key == 'y' or key == 'Y':
                selected = 0  # Yes
                break
            elif key == 'n' or key == 'N':
                selected = 1  # No
                break
            elif allow_always and (key == 'a' or key == 'A'):
                selected = 2  # Always
                break
            elif key == '\x03':  # Ctrl+C
                sys.stdout.write("\033[?25h\n")
                sys.exit(0)

        sys.stdout.write("\033[?25h\n")

        if allow_always:
            if selected == 0:
                return True
            elif selected == 1:
                return False
            else:
                return 'always'
        else:
            return (selected == 0) if default else (selected == 1)

    except Exception:
        sys.stdout.write("\033[?25h\n")
        raise


def get_password_input(prompt):
    """Get password input with asterisk masking."""
    sys.stdout.write(f"{prompt}")
    sys.stdout.flush()

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    password = []

    try:
        tty.setraw(fd)
        while True:
            ch = sys.stdin.read(1)
            if ch == '\r' or ch == '\n':
                break
            elif ch == '\x7f' or ch == '\x08':  # Backspace
                if password:
                    password.pop()
                    sys.stdout.write('\b \b')
                    sys.stdout.flush()
            elif ch == '\x03':  # Ctrl+C
                sys.stdout.write('\n')
                sys.exit(0)
            elif ch >= ' ':  # Printable characters
                password.append(ch)
                sys.stdout.write('*')
                sys.stdout.flush()
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

    sys.stdout.write('\n')
    return ''.join(password)


def load_config():
    """Load configuration from file."""
    if CONFIG_FILE.exists():
        try:
            with open(CONFIG_FILE, "r") as f:
                config = json.load(f)
                # Ensure permissions fields exist
                if "auto_execute_all" not in config:
                    config["auto_execute_all"] = False
                if "allowed_prefixes" not in config:
                    config["allowed_prefixes"] = []
                # Ensure api_keys dict exists (for per-provider key storage)
                if "api_keys" not in config:
                    config["api_keys"] = {}
                    # Migrate old single api_key to new format
                    if config.get("api_key") and config.get("provider"):
                        config["api_keys"][config["provider"]] = config["api_key"]
                return config
        except (json.JSONDecodeError, IOError):
            return None
    return None


def save_config(config):
    """Save configuration to file."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(CONFIG_FILE, "w") as f:
        json.dump(config, f, indent=2)
    os.chmod(CONFIG_FILE, 0o600)  # Secure the file


def update_permissions(config, auto_execute_all=None, allowed_prefixes=None):
    """Update just the permissions in config and save."""
    if auto_execute_all is not None:
        config["auto_execute_all"] = auto_execute_all
    if allowed_prefixes is not None:
        config["allowed_prefixes"] = list(allowed_prefixes)
    save_config(config)


def clear_screen():
    """Clear terminal screen."""
    # Use escape sequences first, then os.system as backup
    sys.stdout.write("\033[2J\033[H")  # Clear screen + move to home
    sys.stdout.write("\033[3J")  # Clear scrollback buffer
    sys.stdout.flush()


def manage_permissions(config):
    """Interactive menu to manage command permissions."""
    message = None  # Status message to show after action
    selected = 0

    while True:
        auto_all = config.get("auto_execute_all", False)
        prefixes = list(config.get("allowed_prefixes", []))

        # Build options
        options = ["Toggle auto-execute ALL", "Add allowed prefix"]
        if prefixes:
            options.append("Remove allowed prefix")
            options.append("Clear all prefixes")
        options.append("Exit")

        # Ensure selected is within bounds
        if selected >= len(options):
            selected = 0

        sys.stdout.write("\033[?25l")  # Hide cursor

        try:
            while True:
                # Build screen content
                lines = []
                lines.append(f"{BOLD}{CYAN}{'═' * 50}{RESET}")
                lines.append(f"{BOLD}{CYAN}  Command Permissions{RESET}")
                lines.append(f"{BOLD}{CYAN}{'═' * 50}{RESET}")
                lines.append("")
                lines.append(f"{BOLD}Current settings:{RESET}")
                if auto_all:
                    lines.append(f"  {GREEN}✓ Auto-execute ALL commands{RESET}")
                else:
                    lines.append(f"  {DIM}✗ Auto-execute all: disabled{RESET}")
                lines.append("")
                if prefixes:
                    lines.append(f"{BOLD}Allowed prefixes:{RESET}")
                    for i, p in enumerate(prefixes, 1):
                        lines.append(f"  {CYAN}{i}.{RESET} {p}...")
                else:
                    lines.append(f"{DIM}No allowed prefixes configured{RESET}")

                if message:
                    lines.append("")
                    lines.append(message)

                lines.append("")
                lines.append(f"{BOLD}Actions:{RESET} {DIM}(↑↓ navigate, Enter select, q quit){RESET}")
                lines.append("")
                for i, opt in enumerate(options):
                    if i == selected:
                        lines.append(f"  {GREEN}❯ {opt}{RESET}")
                    else:
                        lines.append(f"    {DIM}{opt}{RESET}")

                # Clear and draw
                clear_screen()
                print("\n".join(lines))
                sys.stdout.flush()

                # Get input
                key = get_key()

                if key == 'UP' or key == 'k':
                    selected = (selected - 1) % len(options)
                elif key == 'DOWN' or key == 'j':
                    selected = (selected + 1) % len(options)
                elif key == '\r' or key == '\n':
                    break
                elif key == 'q' or key == '\x03':
                    sys.stdout.write("\033[?25h")
                    clear_screen()
                    return config

            sys.stdout.write("\033[?25h")  # Show cursor

            choice = options[selected]
            message = None  # Clear previous message

            if choice == "Exit":
                clear_screen()
                return config

            elif choice == "Toggle auto-execute ALL":
                config["auto_execute_all"] = not auto_all
                save_config(config)
                status = "ENABLED" if config["auto_execute_all"] else "DISABLED"
                message = f"{GREEN}✓ Auto-execute all: {status}{RESET}"

            elif choice == "Add allowed prefix":
                clear_screen()
                sys.stdout.write("\033[?25h")
                print(f"{BOLD}{CYAN}Add Allowed Prefix{RESET}\n")
                new_prefix = input(f"{CYAN}Enter command prefix (e.g., 'ls', 'git status'): {RESET}").strip()
                if new_prefix:
                    if new_prefix not in prefixes:
                        config["allowed_prefixes"] = prefixes + [new_prefix]
                        save_config(config)
                        message = f"{GREEN}✓ Added '{new_prefix}'{RESET}"
                    else:
                        message = f"{YELLOW}'{new_prefix}' already exists{RESET}"

            elif choice == "Remove allowed prefix":
                remove_idx = 0
                remove_options = prefixes + ["← Cancel"]

                while True:
                    # Build remove menu
                    lines = []
                    lines.append(f"{BOLD}{CYAN}Remove Prefix{RESET}")
                    lines.append(f"{DIM}(↑↓ navigate, Enter select){RESET}")
                    lines.append("")
                    for i, opt in enumerate(remove_options):
                        if i == remove_idx:
                            lines.append(f"  {GREEN}❯ {opt}{RESET}")
                        else:
                            lines.append(f"    {DIM}{opt}{RESET}")

                    clear_screen()
                    print("\n".join(lines))
                    sys.stdout.flush()

                    key = get_key()
                    if key == 'UP' or key == 'k':
                        remove_idx = (remove_idx - 1) % len(remove_options)
                    elif key == 'DOWN' or key == 'j':
                        remove_idx = (remove_idx + 1) % len(remove_options)
                    elif key == '\r' or key == '\n':
                        if remove_idx < len(prefixes):
                            removed = prefixes[remove_idx]
                            new_prefixes = prefixes[:remove_idx] + prefixes[remove_idx+1:]
                            config["allowed_prefixes"] = new_prefixes
                            save_config(config)
                            message = f"{GREEN}✓ Removed '{removed}'{RESET}"
                        break
                    elif key == 'q' or key == '\x03' or key == 'ESC':
                        break

            elif choice == "Clear all prefixes":
                clear_screen()
                sys.stdout.write("\033[?25h")
                print(f"{BOLD}{YELLOW}Clear all prefixes?{RESET}\n")
                if interactive_confirm("Are you sure?", default=False):
                    config["allowed_prefixes"] = []
                    save_config(config)
                    message = f"{GREEN}✓ All prefixes cleared{RESET}"

        except Exception:
            sys.stdout.write("\033[?25h\n")
            raise

    return config


def interactive_setup():
    """Run interactive configuration setup."""
    print(f"\n{BOLD}{CYAN}{'═' * 50}{RESET}")
    print(f"{BOLD}{CYAN}  ⚡ Welcome to Termi - Natural Language Terminal{RESET}")
    print(f"{BOLD}{CYAN}{'═' * 50}{RESET}")

    # Load existing config to check for saved API key
    existing_config = load_config()

    # Check Ollama availability and build provider list
    ollama_available = check_ollama_running()
    providers = list(PROVIDERS.keys())

    # State machine for navigation
    step = "provider"
    provider = None
    model = None
    api_key = None

    while True:
        if step == "provider":
            # Build provider display list
            provider_display = []
            for p in providers:
                label = p.upper()
                if p == "ollama":
                    if ollama_available:
                        label += f" {GREEN}(local){RESET}"
                    else:
                        label += f" {DIM}(not running){RESET}"
                provider_display.append(label)

            selected = interactive_select("Select your LLM provider:", provider_display)
            if selected is None:
                continue  # No back from first step, just re-show
            provider_idx = provider_display.index(selected)
            provider = providers[provider_idx]

            # Handle Ollama selection when not running
            if provider == "ollama" and not ollama_available:
                print(f"\n{YELLOW}⚠ Ollama is not running.{RESET}")
                print(f"{DIM}Start Ollama with: ollama serve{RESET}")
                if not interactive_confirm("Continue anyway?", default=False):
                    continue  # Go back to provider selection

            step = "model"

        elif step == "model":
            # Get model list
            if provider == "ollama":
                print(f"\n{DIM}Fetching available Ollama models...{RESET}")
                ollama_models = get_ollama_models()
                if ollama_models is None:
                    print(f"{YELLOW}⚠ Could not connect to Ollama{RESET}")
                    suggested_models = ["llama3.2", "llama3.1", "mistral", "codellama", "phi3"]
                elif len(ollama_models) == 0:
                    print(f"{YELLOW}⚠ No models installed. Install with: ollama pull <model>{RESET}")
                    suggested_models = ["llama3.2", "llama3.1", "mistral", "codellama", "phi3"]
                else:
                    print(f"{GREEN}✓ Found {len(ollama_models)} installed model(s){RESET}")
                    suggested_models = ollama_models
            else:
                suggested_models = PROVIDERS[provider]["suggested_models"]

            model = interactive_select(
                f"Select your {provider.upper()} model:",
                suggested_models,
                allow_custom=True,
                allow_back=True
            )

            if model is None:
                step = "provider"  # Go back
                continue

            step = "api_key"

        elif step == "api_key":
            # Get API key (only for providers that require it)
            if not PROVIDERS[provider]["requires_key"]:
                api_key = None
                break  # Done, no API key needed

            env_key = PROVIDERS[provider]["env_key"]
            env_var_key = os.environ.get(env_key, "")

            # Check for existing saved key for this provider (stored per-provider)
            saved_key = None
            if existing_config:
                # First check api_keys dict (new format)
                saved_key = existing_config.get("api_keys", {}).get(provider)
                # Fallback to old single api_key if same provider
                if not saved_key and existing_config.get("provider") == provider:
                    saved_key = existing_config.get("api_key")

            # If we have a saved key, automatically use it
            if saved_key:
                api_key = saved_key
                masked = saved_key[:8] + "..." + saved_key[-4:] if len(saved_key) > 12 else "***"
                print(f"{GREEN}✓ Using saved API key ({masked}){RESET}")
                break

            # If we have an environment key, use it
            if env_var_key:
                api_key = env_var_key
                masked = env_var_key[:8] + "..." + env_var_key[-4:] if len(env_var_key) > 12 else "***"
                print(f"{GREEN}✓ Using API key from {env_key} ({masked}){RESET}")
                break

            # No existing key - must enter one
            api_key = get_password_input(f"{CYAN}Enter your {provider.upper()} API key (empty to go back): {RESET}")
            if not api_key:
                step = "model"  # Go back
                continue
            break

    # Build api_keys dict, preserving keys from other providers
    api_keys = existing_config.get("api_keys", {}).copy() if existing_config else {}
    if api_key:
        api_keys[provider] = api_key

    # Preserve existing permissions when reconfiguring
    config = {
        "provider": provider,
        "model": model,
        "api_key": api_key,  # Current provider's key for backward compatibility
        "api_keys": api_keys,  # All provider keys
        "auto_execute_all": existing_config.get("auto_execute_all", False) if existing_config else False,
        "allowed_prefixes": existing_config.get("allowed_prefixes", []) if existing_config else []
    }

    save_config(config)

    print(f"\n{GREEN}{'─' * 50}{RESET}")
    print(f"{GREEN}✓ Configuration saved to {CONFIG_FILE}{RESET}")
    print(f"{GREEN}{'─' * 50}{RESET}")
    print(f"\n{BOLD}Setup complete!{RESET} You can now use termi:")
    print(f"  {DIM}$ termi list all files{RESET}")
    print(f"  {DIM}$ termi show disk usage{RESET}")
    print(f"\n{DIM}To reconfigure: termi --config{RESET}\n")

    return config


def call_openai(config, prompt):
    """Call OpenAI API with structured output."""
    headers = {
        "Authorization": f"Bearer {config['api_key']}",
        "Content-Type": "application/json"
    }

    data = {
        "model": config["model"],
        "messages": [
            {"role": "system", "content": "You are a command-line assistant. Convert natural language to shell commands. Return JSON with commands array and unsafe boolean."},
            {"role": "user", "content": prompt}
        ],
        "response_format": {
            "type": "json_schema",
            "json_schema": {
                "name": "command_response",
                "strict": True,
                "schema": {
                    "type": "object",
                    "properties": {
                        "commands": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "cmd": {"type": "string", "description": "The shell command to execute"},
                                    "desc": {"type": "string", "description": "Brief description of what the command does"}
                                },
                                "required": ["cmd", "desc"],
                                "additionalProperties": False
                            },
                            "description": "List of commands to execute in order"
                        },
                        "unsafe": {
                            "type": "boolean",
                            "description": "True if the request is dangerous or unclear"
                        }
                    },
                    "required": ["commands", "unsafe"],
                    "additionalProperties": False
                }
            }
        }
    }

    response = requests.post(
        "https://api.openai.com/v1/chat/completions",
        headers=headers,
        json=data,
        timeout=30
    )

    if response.status_code != 200:
        try:
            error_detail = response.json()
            print(f"{RED}API Error: {error_detail.get('error', {}).get('message', response.text)}{RESET}")
        except:
            print(f"{RED}API Error: {response.text}{RESET}")
        response.raise_for_status()

    return response.json()["choices"][0]["message"]["content"].strip()


def call_anthropic(config, prompt):
    """Call Anthropic API."""
    headers = {
        "x-api-key": config["api_key"],
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01"
    }
    data = {
        "model": config["model"],
        "max_tokens": 500,
        "system": SYSTEM_PROMPT,
        "messages": [
            {"role": "user", "content": prompt}
        ]
    }

    response = requests.post(
        PROVIDERS["anthropic"]["api_url"],
        headers=headers,
        json=data,
        timeout=30
    )

    if response.status_code != 200:
        try:
            error_detail = response.json()
            print(f"{RED}API Error: {error_detail.get('error', {}).get('message', response.text)}{RESET}")
        except:
            print(f"{RED}API Error: {response.text}{RESET}")
        response.raise_for_status()

    return response.json()["content"][0]["text"].strip()


def clean_llm_response(text):
    """Clean up LLM response by removing thinking tags and extracting JSON."""
    # Remove <think>...</think> blocks (including multiline)
    text = re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL | re.IGNORECASE)

    # Remove <thinking>...</thinking> blocks
    text = re.sub(r'<thinking>.*?</thinking>', '', text, flags=re.DOTALL | re.IGNORECASE)

    # Remove <reasoning>...</reasoning> blocks
    text = re.sub(r'<reasoning>.*?</reasoning>', '', text, flags=re.DOTALL | re.IGNORECASE)

    # Remove markdown code blocks wrapper
    text = re.sub(r'^```(?:json)?\n?', '', text.strip())
    text = re.sub(r'\n?```$', '', text.strip())

    return text.strip()


def parse_llm_response(text):
    """Parse LLM response and extract structured command data."""
    text = clean_llm_response(text)

    try:
        # Try to parse as JSON
        data = json.loads(text)

        if isinstance(data, dict):
            commands = data.get("commands", [])
            unsafe = data.get("unsafe", False)

            if unsafe or not commands:
                return {"commands": [], "unsafe": True}

            # Normalize commands format
            normalized = []
            for cmd in commands:
                if isinstance(cmd, dict):
                    normalized.append({
                        "cmd": cmd.get("cmd", ""),
                        "desc": cmd.get("desc", "")
                    })
                elif isinstance(cmd, str):
                    normalized.append({"cmd": cmd, "desc": ""})

            return {"commands": normalized, "unsafe": False}

    except json.JSONDecodeError:
        # Fallback: try to extract command from plain text
        lines = [l.strip() for l in text.split('\n') if l.strip()]
        if lines:
            # Check for unsafe markers
            first_line = lines[0].lower()
            if "unsafe" in first_line or "cannot" in first_line or "sorry" in first_line:
                return {"commands": [], "unsafe": True}

            return {
                "commands": [{"cmd": lines[0], "desc": ""}],
                "unsafe": False
            }

    return {"commands": [], "unsafe": True}


def call_ollama(config, prompt):
    """Call Ollama API."""
    data = {
        "model": config["model"],
        "messages": [
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": prompt}
        ],
        "stream": False,
        "format": "json",
        "options": {
            "temperature": 0,
            "num_predict": 500
        }
    }

    response = requests.post(
        PROVIDERS["ollama"]["api_url"],
        json=data,
        timeout=120  # Local models may be slower
    )
    response.raise_for_status()
    raw_response = response.json()["message"]["content"].strip()
    return clean_llm_response(raw_response)


def translate_to_commands(config, natural_language):
    """Translate natural language to shell commands. Returns structured data."""
    try:
        if config["provider"] == "openai":
            raw_response = call_openai(config, natural_language)
        elif config["provider"] == "anthropic":
            raw_response = call_anthropic(config, natural_language)
        elif config["provider"] == "ollama":
            raw_response = call_ollama(config, natural_language)
        else:
            print(f"{RED}Error: Unknown provider {config['provider']}{RESET}")
            sys.exit(1)

        return parse_llm_response(raw_response)

    except requests.exceptions.ConnectionError:
        if config["provider"] == "ollama":
            print(f"{RED}Error: Cannot connect to Ollama. Is it running?{RESET}")
            print(f"{DIM}Start with: ollama serve{RESET}")
        else:
            print(f"{RED}Error: Connection failed{RESET}")
        sys.exit(1)
    except requests.exceptions.RequestException as e:
        print(f"{RED}Error calling API: {e}{RESET}")
        sys.exit(1)


def execute_command(command):
    """Execute a shell command and print output."""
    try:
        result = subprocess.run(
            command,
            shell=True,
            capture_output=True,
            text=True
        )
        if result.stdout:
            print(result.stdout, end="")
        if result.stderr:
            print(result.stderr, end="", file=sys.stderr)
        return result.returncode
    except Exception as e:
        print(f"{RED}Error executing command: {e}{RESET}")
        return 1


def get_command_prefix(cmd):
    """Extract a meaningful prefix from a command for allowlisting."""
    parts = cmd.strip().split()
    if not parts:
        return cmd
    # If sudo, include the actual command after sudo
    if parts[0] == "sudo" and len(parts) >= 2:
        return f"sudo {parts[1]}"
    # Otherwise just the first word (the command)
    return parts[0]


def check_command_allowed(cmd, allowed_prefixes, auto_execute_all):
    """Check if a command is allowed based on prefixes or auto-execute flag."""
    if auto_execute_all:
        return True
    for prefix in allowed_prefixes:
        if cmd.strip().startswith(prefix):
            return True
    return False


def confirm_command_execution(cmd, allowed_prefixes):
    """
    Ask for confirmation with arrow key navigation.
    Returns: (execute: bool, allow_prefix: str|None, allow_all: bool)
    """
    prefix = get_command_prefix(cmd)

    options = [
        "Yes - execute",
        "No - skip",
        f"Always allow '{prefix}...'",
        "Always allow all"
    ]

    selected = 0

    sys.stdout.write("\033[?25l")  # Hide cursor
    sys.stdout.flush()

    try:
        while True:
            sys.stdout.write(f"\n{BOLD}Execute?{RESET} {DIM}(↑↓ or j/k to navigate, Enter to select){RESET}\n\n")

            for i, opt in enumerate(options):
                if i == selected:
                    sys.stdout.write(f"  {GREEN}❯ {opt}{RESET}\n")
                else:
                    sys.stdout.write(f"    {DIM}{opt}{RESET}\n")

            sys.stdout.flush()

            key = get_key()

            if key == 'UP' or key == 'k':
                selected = (selected - 1) % len(options)
            elif key == 'DOWN' or key == 'j':
                selected = (selected + 1) % len(options)
            elif key == '\r' or key == '\n':
                break
            elif key == '\x03':  # Ctrl+C
                sys.stdout.write("\033[?25h\n")
                sys.exit(0)

            # Clear and redraw
            lines = len(options) + 3
            sys.stdout.write(f"\033[{lines}A")
            for _ in range(lines):
                sys.stdout.write(f"{CLEAR_LINE}\n")
            sys.stdout.write(f"\033[{lines}A")

        sys.stdout.write("\033[?25h\n")

        if selected == 0:
            return (True, None, False)
        elif selected == 1:
            return (False, None, False)
        elif selected == 2:
            return (True, prefix, False)
        else:
            return (True, None, True)

    except Exception:
        sys.stdout.write("\033[?25h\n")
        raise


def interactive_mode(config):
    """Run in interactive mode."""
    print(f"\n{BOLD}{CYAN}{'═' * 50}{RESET}")
    print(f"{BOLD}{CYAN}  ⚡ Termi Interactive Mode{RESET}")
    print(f"{BOLD}{CYAN}{'═' * 50}{RESET}")
    print(f"{DIM}Type natural language commands, 'exit' to quit, 'permissions' to manage auto-execute{RESET}\n")

    # Load permissions from config
    auto_execute_all = config.get("auto_execute_all", False)
    allowed_prefixes = set(config.get("allowed_prefixes", []))

    if auto_execute_all:
        print(f"{GREEN}✓ Auto-execute ALL commands is enabled{RESET}\n")
    elif allowed_prefixes:
        print(f"{GREEN}✓ Auto-execute enabled for {len(allowed_prefixes)} prefix(es){RESET}\n")

    while True:
        try:
            user_input = input(f"{BOLD}{GREEN}termi❯{RESET} ").strip()

            if not user_input:
                continue

            if user_input.lower() in ("exit", "quit", "q"):
                print(f"{DIM}Goodbye!{RESET}")
                break

            if user_input.lower() == "config":
                config = interactive_setup()
                # Reload permissions from new config
                auto_execute_all = config.get("auto_execute_all", False)
                allowed_prefixes = set(config.get("allowed_prefixes", []))
                continue

            if user_input.lower() in ("permissions", "perms", "perm"):
                config = manage_permissions(config)
                # Reload permissions from updated config
                auto_execute_all = config.get("auto_execute_all", False)
                allowed_prefixes = set(config.get("allowed_prefixes", []))
                continue

            if user_input.lower() == "reset":
                auto_execute_all = False
                allowed_prefixes.clear()
                update_permissions(config, auto_execute_all=False, allowed_prefixes=[])
                print(f"{GREEN}✓ All auto-execute settings reset and saved{RESET}")
                continue

            if user_input.lower() == "allowed":
                if auto_execute_all:
                    print(f"{CYAN}Auto-execute: {BOLD}ALL commands{RESET}")
                elif allowed_prefixes:
                    print(f"{CYAN}Allowed prefixes:{RESET}")
                    for p in sorted(allowed_prefixes):
                        print(f"  {GREEN}✓{RESET} {p}...")
                else:
                    print(f"{DIM}No auto-execute rules set{RESET}")
                continue

            # Translate to commands
            print(f"{DIM}Translating...{RESET}")
            result = translate_to_commands(config, user_input)

            if result["unsafe"] or not result["commands"]:
                print(f"{RED}✗ Request declined: potentially unsafe or unclear command.{RESET}")
                continue

            commands = result["commands"]

            # Display commands
            print(f"\n{YELLOW}Commands to execute:{RESET}")
            for i, cmd in enumerate(commands, 1):
                desc = f" {DIM}# {cmd['desc']}{RESET}" if cmd.get('desc') else ""
                allowed = check_command_allowed(cmd['cmd'], allowed_prefixes, auto_execute_all)
                status = f" {GREEN}✓{RESET}" if allowed else ""
                print(f"  {CYAN}{i}.{RESET} {BOLD}{cmd['cmd']}{RESET}{desc}{status}")
            print()

            # Execute commands one by one
            for i, cmd in enumerate(commands, 1):
                cmd_str = cmd['cmd']

                # Check if command is auto-allowed
                if check_command_allowed(cmd_str, allowed_prefixes, auto_execute_all):
                    print(f"{DIM}(Auto-allowed){RESET}")
                    should_execute = True
                else:
                    execute, prefix, allow_all = confirm_command_execution(cmd_str, allowed_prefixes)

                    if allow_all:
                        auto_execute_all = True
                        update_permissions(config, auto_execute_all=True)
                        print(f"{GREEN}✓ Auto-execute ALL enabled and saved (type 'reset' to disable){RESET}")

                    if prefix:
                        allowed_prefixes.add(prefix)
                        update_permissions(config, allowed_prefixes=list(allowed_prefixes))
                        print(f"{GREEN}✓ Always allowing '{prefix}...' - saved (type 'reset' to clear){RESET}")

                    should_execute = execute

                if should_execute:
                    print(f"{CYAN}{'─' * 40}{RESET}")
                    print(f"{DIM}[{i}/{len(commands)}] {cmd_str}{RESET}")
                    exit_code = execute_command(cmd_str)
                    if exit_code != 0:
                        print(f"{YELLOW}⚠ Command exited with code {exit_code}{RESET}")
                        if len(commands) > i:
                            if not auto_execute_all:
                                if not interactive_confirm("Continue with remaining commands?", default=False):
                                    print(f"{DIM}Remaining commands skipped.{RESET}")
                                    break
                    print(f"{CYAN}{'─' * 40}{RESET}")
                else:
                    print(f"{DIM}Skipped.{RESET}")
                    if len(commands) > i:
                        if not interactive_confirm("Continue with remaining commands?", default=True):
                            print(f"{DIM}Remaining commands skipped.{RESET}")
                            break

        except KeyboardInterrupt:
            print(f"\n{DIM}Goodbye!{RESET}")
            break
        except EOFError:
            print(f"\n{DIM}Goodbye!{RESET}")
            break


def main():
    """Main entry point."""
    args = sys.argv[1:]

    # Handle --config flag
    if "--config" in args or "-c" in args:
        interactive_setup()
        return

    # Handle --permissions flag
    if "--permissions" in args or "-p" in args:
        config = load_config()
        if config is None:
            print(f"{YELLOW}No configuration found. Running setup first.{RESET}")
            config = interactive_setup()
        manage_permissions(config)
        return

    # Handle --help flag
    if "--help" in args or "-h" in args:
        print(f"""
{BOLD}Termi - Natural Language Terminal{RESET}

{CYAN}Usage:{RESET}
  termi                     Start interactive mode (setup on first run)
  termi <natural language>  Execute a natural language command
  termi --config            Reconfigure settings
  termi --permissions       Manage auto-execute permissions
  termi --help              Show this help message

{CYAN}Interactive commands:{RESET}
  permissions               Open permissions management menu
  reset                     Clear all auto-execute permissions
  allowed                   Show current auto-execute rules
  config                    Reconfigure LLM settings
  exit                      Exit interactive mode

{CYAN}Examples:{RESET}
  termi list all files
  termi show me disk usage
  termi find all python files in src folder
  termi count lines in all javascript files
        """)
        return

    # Load or create config
    config = load_config()

    if config is None:
        config = interactive_setup()

    # If no arguments, run interactive mode
    if not args:
        interactive_mode(config)
        return

    # Process natural language command from arguments
    # Filter out flags
    cmd_args = [a for a in args if not a.startswith('-')]
    natural_language = " ".join(cmd_args)

    result = translate_to_commands(config, natural_language)

    if result["unsafe"] or not result["commands"]:
        print(f"{RED}✗ Request declined: potentially unsafe or unclear command.{RESET}")
        sys.exit(1)

    commands = result["commands"]

    # Load permissions from config
    auto_execute_all = config.get("auto_execute_all", False)
    allowed_prefixes = set(config.get("allowed_prefixes", []))

    # Display commands with auto-allowed status
    print(f"\n{YELLOW}Commands to execute:{RESET}")
    for i, cmd in enumerate(commands, 1):
        desc = f" {DIM}# {cmd['desc']}{RESET}" if cmd.get('desc') else ""
        allowed = check_command_allowed(cmd['cmd'], allowed_prefixes, auto_execute_all)
        status = f" {GREEN}✓{RESET}" if allowed else ""
        print(f"  {CYAN}{i}.{RESET} {BOLD}{cmd['cmd']}{RESET}{desc}{status}")
    print()

    # Override with --yes flag if provided
    auto_yes = "--yes" in sys.argv or "-y" in sys.argv
    if auto_yes:
        auto_execute_all = True

    # Execute commands sequentially
    final_exit_code = 0
    for i, cmd in enumerate(commands, 1):
        cmd_str = cmd['cmd']

        if auto_execute_all:
            should_execute = True
        elif check_command_allowed(cmd_str, allowed_prefixes, False):
            print(f"{DIM}(Auto-allowed){RESET}")
            should_execute = True
        else:
            execute, prefix, allow_all = confirm_command_execution(cmd_str, allowed_prefixes)

            if allow_all:
                auto_execute_all = True
                update_permissions(config, auto_execute_all=True)
                print(f"{GREEN}✓ Auto-execute ALL enabled and saved{RESET}")

            if prefix:
                allowed_prefixes.add(prefix)
                update_permissions(config, allowed_prefixes=list(allowed_prefixes))
                print(f"{GREEN}✓ Always allowing '{prefix}...' - saved{RESET}")

            should_execute = execute

        if not should_execute:
            print(f"{DIM}Skipped.{RESET}")
            if len(commands) > i:
                if not interactive_confirm("Continue with remaining commands?", default=True):
                    print(f"{DIM}Remaining commands skipped.{RESET}")
                    break
            continue

        print(f"{CYAN}{'─' * 40}{RESET}")
        print(f"{DIM}[{i}/{len(commands)}] {cmd_str}{RESET}")
        exit_code = execute_command(cmd_str)
        if exit_code != 0:
            print(f"{YELLOW}⚠ Command exited with code {exit_code}{RESET}")
            final_exit_code = exit_code
            if len(commands) > i and not auto_execute_all:
                if not interactive_confirm("Continue with remaining commands?", default=False):
                    print(f"{DIM}Remaining commands skipped.{RESET}")
                    break
        print(f"{CYAN}{'─' * 40}{RESET}")

    sys.exit(final_exit_code)


if __name__ == "__main__":
    main()
